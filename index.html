<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>ESL Survivors 3D</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&family=Orbitron:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0; background-color: #0d0d1a; color: #e0e0e0; font-family: 'Roboto', sans-serif; overflow: hidden;
            touch-action: none; -webkit-touch-callout: none; -webkit-user-select: none; user-select: none;
        }
        #game-container { position: relative; width: 100vw; height: 100vh; background-color: #1a1a2a; }
        #gameCanvas { display: block; width: 100%; height: 100%; }
        .modal {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background-color: rgba(30, 30, 50, 0.9); padding: 2rem; border-radius: 15px; border: 3px solid #00ffff;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.7); text-align: center; z-index: 100; width: 90%; max-width: 500px;
            font-family: 'Orbitron', sans-serif; letter-spacing: 1px;
            touch-action: auto;
        }
        .modal h1, .modal h2 { color: #00ffff; text-shadow: 0 0 5px #00ffff; }
        .modal p { font-family: 'Roboto', sans-serif; letter-spacing: 0; color: #ccc;}
        .modal-button {
            background-color: #00ffff; color: #1e1e32; font-family: 'Orbitron', sans-serif; font-size: 1.5rem; letter-spacing: 2px;
            padding: 0.8rem 1.5rem; border-radius: 10px; border: 2px solid #80ffff; cursor: pointer; transition: all 0.2s ease;
            margin-top: 1rem; box-shadow: 0 4px #00cccc;
        }
        .modal-button:hover { background-color: #80ffff; box-shadow: 0 2px #00cccc; transform: translateY(2px); }
        .nickname-input {
            background-color: rgba(0,0,0,0.5); border: 2px solid #00ffff; color: #00ffff;
            border-radius: 8px; padding: 0.5rem; text-align: center; font-family: 'Roboto', sans-serif;
            touch-action: auto;
            -webkit-user-select: text;
            user-select: text;
        }
        #xp-bar-container { width: 100%; height: 15px; background-color: #444; border: 2px solid #39ff14; border-radius: 5px; overflow: hidden; }
        #xp-bar-fill { height: 100%; background-color: #39ff14; width: 0%; transition: width 0.3s ease; }
        #touch-controls-container { position: absolute; bottom: 0; left: 0; right: 0; top: 0; z-index: 20; pointer-events: none; }
        .joystick-area { position: absolute; bottom: 20px; left: 20px; width: 150px; height: 150px; background-color: rgba(100, 100, 100, 0.2); border: 2px solid rgba(0, 255, 255, 0.5); border-radius: 50%; pointer-events: auto; }
        .joystick-nub { position: absolute; top: 50%; left: 50%; width: 60px; height: 60px; background-color: rgba(0, 255, 255, 0.5); border: 2px solid rgba(128, 255, 255, 0.8); border-radius: 50%; transform: translate(-50%, -50%); }
        #shoot-area { position: absolute; bottom: 0; right: 0; top: 0; left: 50%; pointer-events: auto;}
        
        .touch-dash-button {
            position: absolute;
            bottom: 140px;
            right: 20px;
            width: 80px; 
            height: 80px; 
            background-color: rgba(0, 200, 0, 0.5);
            border: 2px solid rgba(0, 255, 0, 0.8);
            border-radius: 50%;
            pointer-events: auto;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: 'Orbitron', sans-serif;
            font-size: 1.2rem;
            color: white;
            z-index: 21;
            overflow: hidden;
        }
        .touch-dash-cooldown {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background-color: rgba(0, 0, 0, 0.7);
            transform: translateY(100%);
            transition: transform 0.1s linear;
        }

        .touch-bomb-button {
            position: absolute;
            bottom: 240px;
            right: 20px;
            width: 80px;
            height: 80px;
            background-color: rgba(255, 100, 0, 0.5);
            border: 2px solid rgba(255, 150, 0, 0.8);
            border-radius: 50%;
            pointer-events: auto;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: 'Orbitron', sans-serif;
            font-size: 2rem;
            color: white;
            z-index: 21;
        }

        .touch-question-button {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 100px;
            height: 100px;
            background-color: rgba(128, 0, 128, 0.5);
            border: 2px solid rgba(255, 0, 255, 0.8);
            border-radius: 50%;
            pointer-events: auto;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: 'Orbitron', sans-serif;
            font-size: 3rem;
            color: white;
            z-index: 21;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <!-- 3D Canvas and UI elements will be created here -->
    </div>

    <script type="module">
        // --- Three.js Scene Setup ---
        let scene, camera, renderer, clock;
        let player3D, enemies3D = [], projectiles3D = [], xpOrbs3D = [], particles3D = [];
        let enemyProjectiles3D = [], orbitalWeapons3D = [], stunProjectiles3D = [];
        let groundMesh, lavaPits3D = [];
        let ambientLight, directionalLight, playerLight;

        // --- DOM Elements ---
        const getEl = id => document.getElementById(id);
        const gameContainer = document.getElementById('game-container');
        let hud, scoreText, levelText, timeText, xp_hud, xpBarFill,
            levelUpModal, upgradeOptionsContainer,
            gameOverModal, finalScore, finalTime, restartButton,
            touchControlsContainer, joystickArea, joystickNub, shootArea,
            ammoText, bombText, biomeText, hudQuestionButton, questionModal, questionText, answerButtons,
            finalQuestionsCorrect, finalQuestionsIncorrect,
            touchQuestionButton, touchDashButton, touchDashCooldown, touchBombButton;

        function createUI() {
            gameContainer.innerHTML = `
                <div id="gameCanvas"></div>
                <div id="touch-controls-container" class="hidden">
                    <div id="joystick-area" class="joystick-area"><div id="joystick-nub" class="joystick-nub"></div></div>
                    <div id="shoot-area"></div>
                    <div id="touch-bomb-button" class="touch-bomb-button">ðŸ’£</div>
                    <div id="touch-dash-button" class="touch-dash-button">
                        Dash
                        <div id="touch-dash-cooldown" class="touch-dash-cooldown"></div>
                    </div>
                    <div id="touch-question-button" class="touch-question-button">?</div>
                </div>
                <div id="hud" class="absolute top-0 left-0 right-0 p-3 text-sm sm:text-base flex justify-between items-center text-white bg-black/30 hidden">
                    <div>
                        <div>Ammo: <span id="ammo-text">50</span> <button id="hud-question-button" class="ml-2 px-2 py-0.5 text-xs bg-purple-700 rounded hover:bg-purple-600">?</button></div>
                        <div>Bombs: <span id="bomb-text">3</span></div>
                        <div>Score: <span id="score-text">0</span></div>
                    </div>
                    <div>
                        <div>Level: <span id="level-text">1</span></div>
                        <div>Biome: <span id="biome-text" style="font-weight: bold;">Normal World</span></div>
                    </div>
                    <div>Time: <span id="time-text">0s</span></div>
                </div>
                <div id="xp-hud" class="absolute bottom-0 left-0 right-0 p-3 bg-black/30 hidden">
                    <div id="xp-bar-container"><div id="xp-bar-fill"></div></div>
                </div>
                
                <div id="question-modal" class="modal hidden">
                    <h2 class="text-3xl sm:text-4xl mb-4">Ammo Question!</h2>
                    <p id="question-text" class="text-lg mb-6"></p>
                    <div id="answer-buttons" class="grid grid-cols-1 sm:grid-cols-2 gap-3 sm:gap-4"></div>
                </div>
                 <div id="level-up-modal" class="modal hidden">
                    <h2 class="text-3xl sm:text-4xl text-yellow-400 mb-6">Level Up!</h2>
                    <p class="mb-4">Choose an upgrade:</p>
                    <div id="upgrade-options-container" class="space-y-3 sm:space-y-4"></div>
                </div>
                <div id="game-over-modal" class="modal hidden">
                     <h2 class="text-4xl sm:text-5xl text-red-500 mb-2">Game Over!</h2>
                     <div class="text-left text-sm sm:text-base space-y-2 mb-6 bg-black/40 p-4 rounded-lg border border-cyan-500">
                         <p>Enemies Defeated: <span id="final-score" class="font-bold text-white float-right">0</span></p>
                         <p>Time Survived: <span id="final-time" class="font-bold text-white float-right">0s</span></p>
                         <hr class="border-cyan-500/50 my-2">
                         <p>Correct: <span id="final-questions-correct" class="font-bold text-green-400 float-right">0</span></p>
                         <p>Incorrect: <span id="final-questions-incorrect" class="font-bold text-red-400 float-right">0</span></p>
                     </div>
                     <button id="restart-button" class="modal-button">Play Again</button>
                </div>
            `;
        }
        createUI();

        function initUI() {
            hud = getEl('hud');
            ammoText = getEl('ammo-text');
            bombText = getEl('bomb-text');
            scoreText = getEl('score-text');
            levelText = getEl('level-text');
            biomeText = getEl('biome-text');
            timeText = getEl('time-text');
            xp_hud = getEl('xp-hud');
            xpBarFill = getEl('xp-bar-fill');
            questionModal = getEl('question-modal');
            questionText = getEl('question-text');
            answerButtons = getEl('answer-buttons');
            levelUpModal = getEl('level-up-modal');
            upgradeOptionsContainer = getEl('upgrade-options-container');
            gameOverModal = getEl('game-over-modal');
            finalScore = getEl('final-score');
            finalTime = getEl('final-time');
            finalQuestionsCorrect = getEl('final-questions-correct');
            finalQuestionsIncorrect = getEl('final-questions-incorrect');
            restartButton = getEl('restart-button');
            touchControlsContainer = getEl('touch-controls-container');
            joystickArea = getEl('joystick-area');
            joystickNub = getEl('joystick-nub');
            shootArea = getEl('shoot-area');
            hudQuestionButton = getEl('hud-question-button');
            touchQuestionButton = getEl('touch-question-button');
            touchDashButton = getEl('touch-dash-button');
            touchDashCooldown = getEl('touch-dash-cooldown');
            touchBombButton = getEl('touch-bomb-button');
        }

        // --- Three.js Initialization ---
        function init3D() {
            scene = new THREE.Scene();
            clock = new THREE.Clock();

            // Camera setup - isometric-style view
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 40, 30);
            camera.lookAt(0, 0, 0);

            // Renderer setup
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            const canvasDiv = getEl('gameCanvas');
            if (canvasDiv) canvasDiv.appendChild(renderer.domElement);

            // Lighting
            ambientLight = new THREE.AmbientLight(0x404040);
            scene.add(ambientLight);

            directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(10, 20, 10);
            directionalLight.castShadow = true;
            directionalLight.shadow.camera.left = -50;
            directionalLight.shadow.camera.right = 50;
            directionalLight.shadow.camera.top = 50;
            directionalLight.shadow.camera.bottom = -50;
            scene.add(directionalLight);

            // Player light that follows player
            playerLight = new THREE.PointLight(0x00ffff, 0.5, 20);
            playerLight.position.y = 5;
            scene.add(playerLight);

            // Create ground
            const groundGeometry = new THREE.PlaneGeometry(100, 100, 20, 20);
            const groundMaterial = new THREE.MeshLambertMaterial({ color: 0x2a2a3a });
            groundMesh = new THREE.Mesh(groundGeometry, groundMaterial);
            groundMesh.rotation.x = -Math.PI / 2;
            groundMesh.receiveShadow = true;
            scene.add(groundMesh);

            // Add grid helper
            const gridHelper = new THREE.GridHelper(100, 50, 0x333333, 0x333333);
            scene.add(gridHelper);
        }

        // --- Game State & Config ---
        let player, enemies = [], projectiles = [], xpOrbs = [], powerUpDrops = [];
        let particles = [];
        let enemyProjectiles = [];
        let orbitalWeapons = [];
        let stunProjectiles = [];
        let score = 0, gameTime = 0, spawnTimer = 0, gamePaused = false, gameOver = false, correctAnswers = 0, incorrectAnswers = 0;
        let bossSpawnedLevel3 = false, bossSpawnedLevel5 = false, bossSpawnedLevel10 = false;
        let lastShotTime = 0, gameLoopId;
        let chargeStartTime = 0, isCharging = false;
        let killStreak = 0;
        let playerNickname = "ESL_Survivor";
        let isTouchDevice = false;
        let joystickTouchId = null;
        let joystickStart = { x: 0, y: 0 };
        let moveInput = { x: 0, y: 0 };
        let activeTouches = {};
        let world = { width: 100, height: 100 }; // Adjusted for 3D

        // --- Biome System ---
        let currentBiome = 'normal';
        let lavaPits = [];
        const biomes = {
            normal: {
                name: 'Normal World',
                backgroundColor: '#1a1a2a',
                gridColor: 0x333333,
                groundColor: 0x2a2a3a,
                fogColor: 0x1a1a2a
            },
            ice: {
                name: 'Ice World',
                backgroundColor: '#0a1a2a',
                gridColor: 0x336699,
                groundColor: 0x1a3a5a,
                friction: 0.92,
                iceColor: 0x4db8ff,
                fogColor: 0x0a1a2a
            },
            heat: {
                name: 'Heat World',
                backgroundColor: '#2a1a0a',
                gridColor: 0x663333,
                groundColor: 0x4a2a1a,
                lavaColor: 0xff4400,
                lavaDamage: 2,
                maxLavaPits: 8,
                fogColor: 0x2a1a0a
            }
        };
        let biomeOrder = ['normal', 'ice', 'heat', 'normal'];
        let biomeIndex = 0;

        const playerStats = {
            x: 0, y: 0, z: 0, size: 1, speed: 15, health: 100, maxHealth: 100, ammo: 50,
            fireRate: 500, projectileSpeed: 25, projectileSize: 0.3, projectileDamage: 25,
            shotCount: 1, pickupRadius: 5, level: 1, xp: 0, xpToNextLevel: 100,
            pierce: 0, spread: 0,
            weaponAngle: 0, vx: 0, vz: 0,
            dashSpeed: 50,
            dashDuration: 150,
            dashCooldown: 5000,
            lastDashTime: 0,
            isDashing: false,
            dashTimer: 0,
            bombs: 3,
            bombDamage: 100,
            bombRadius: 15,
            bombCooldown: 10000,
            lastBombTime: -10000
        };

        const enemyTypes = [
            { id_key: "Drone", name: "Drone", size: 1, speed: 8, health: 40, xp: 10, shape: 'cube', color: 0xff4444, damage: 5, maxHealth: 40 },
            { id_key: "Robot", name: "Robot", size: 2, speed: 2, health: 120, xp: 40, shape: 'box', color: 0x4488ff, damage: 10, maxHealth: 120 },
            { id_key: "Scout", name: "Scout", size: 0.7, speed: 12, health: 30, xp: 18, shape: 'cube', color: 0xffff44, damage: 4, maxHealth: 30 },
            { id_key: "Swarm", name: "Swarm", size: 0.4, speed: 14, health: 10, xp: 15, shape: 'cube', color: 0x88ff88, damage: 1, maxHealth: 10 },
            { id_key: "Flyer", name: "Flyer", size: 0.6, speed: 15, health: 25, xp: 20, shape: 'sphere', color: 0xff88ff, damage: 3, maxHealth: 25, flying: true },
            { id_key: "Tank", name: "Tank", size: 3, speed: 1.5, health: 300, xp: 60, shape: 'box', color: 0x666666, damage: 20, maxHealth: 300 },
            { id_key: "Assassin", name: "Assassin", size: 0.8, speed: 18, health: 20, xp: 35, shape: 'cube', color: 0x8800ff, damage: 15, maxHealth: 20 },
            { id_key: "Healer", name: "Healer", size: 1.2, speed: 5, health: 60, xp: 50, shape: 'sphere', color: 0x00ff88, damage: 2, maxHealth: 60, isHealer: true, healCooldown: 2000, lastHealTime: 0, healAmount: 15, healRadius: 8 },
            { id_key: "Splitter", name: "Splitter", size: 1.5, speed: 6, health: 80, xp: 45, shape: 'cube', color: 0xff8800, damage: 8, maxHealth: 80, isSplitter: true },
            { id_key: "Bomber", name: "Bomber", size: 1, speed: 10, health: 35, xp: 30, shape: 'sphere', color: 0xff0088, damage: 25, maxHealth: 35, isBomber: true, explosionRadius: 5, explosionDamage: 30 },
        ];
        const bossType = { id_key: "Boss", name: "Boss", size: 4, speed: 4, health: 900, xp: 2000, shape: 'box', color: 0xff0000, damage: 250, maxHealth: 500, isBoss: true, shootCooldown: 200, lastShotTime: 0 };

        const powerUpTypes = {
            'HEALTH': { name: "Health Pack", description: "+50 Max HP", apply: (p) => { p.maxHealth += 50; p.health = Math.min(p.maxHealth, p.health + 50); } },
            'SPEED': { name: "Speed Boost", description: "+25% Move Speed", apply: (p) => p.speed *= 1.8 },
            'FIRE_RATE': { name: "Rapid Fire", description: "-25% Firing Delay", apply: (p) => p.fireRate *= 1.75 },
            'DAMAGE': { name: "Damage Up", description: "+15 Damage", apply: (p) => p.projectileDamage += 15 },
            'MULTISHOT': { name: "Spread Shot", description: "+2 Projectiles", apply: (p) => p.shotCount += 2 },
            'PIERCE': { name: "Piercing Shot", description: "Shots pierce +2 enemies", apply: (p) => p.pierce += 2 },
            'RANGE': { name: "Long-Range", description: "+50% Projectile Lifetime", apply: (p) => p.projectileLifetime = (p.projectileLifetime || 3) * 1.5 },
            'PICKUP': { name: "XP Magnet", description: "+75% Pickup Radius", apply: (p) => p.pickupRadius *= 1.75 },
            'BOMB_CAPACITY': { name: "Bomb Cache", description: "+2 Bombs", apply: (p) => p.bombs += 2 },
            'BOMB_DAMAGE': { name: "Explosive Power", description: "+50 Bomb Damage", apply: (p) => p.bombDamage += 50 },
            'BOMB_RADIUS': { name: "Bigger Boom", description: "+50% Bomb Radius", apply: (p) => p.bombRadius *= 1.5 },
            'SHIELD': { name: "Armor Plating", description: "+30 Max HP & Damage Reduction", apply: (p) => { p.maxHealth += 30; p.health += 30; p.damageReduction = (p.damageReduction || 0) + 0.1; } },
            'LIFESTEAL': { name: "Vampire", description: "Heal 5 HP on kill", apply: (p) => p.lifesteal = (p.lifesteal || 0) + 5 },
            'CRIT_CHANCE': { name: "Critical Strike", description: "15% chance for 2x damage", apply: (p) => p.critChance = (p.critChance || 0) + 0.15 },
            'DASH_COOLDOWN': { name: "Quick Dash", description: "-30% Dash Cooldown", apply: (p) => p.dashCooldown *= 0.7 },
            'ORBITAL_AXE': { name: "Spinning Axes", description: "Axes orbit around you", apply: (p) => { p.orbitalCount = (p.orbitalCount || 0) + 1; addOrbitalWeapon(); } },
            'CHARGE_SHOT': { name: "Mega Cannon", description: "Hold Space for huge shot", apply: (p) => p.hasChargeShot = true },
            'STUN_SHOT': { name: "Stunner", description: "Stun projectiles pierce infinitely", apply: (p) => p.hasStunShot = true },
            'RAGE_MODE': { name: "Berserker Rage", description: "10s mega boost at low HP", apply: (p) => p.hasRageMode = true }
        };

        // --- Question Generator ---
        const questionGenerator = {
            verbBank: [
                { base: 'go', past: 'went', ing: 'going', pastParticiple: 'gone', object: 'to the store' },
                { base: 'eat', past: 'ate', ing: 'eating', pastParticiple: 'eaten', object: 'a large pizza' },
                { base: 'sleep', past: 'slept', ing: 'sleeping', pastParticiple: 'slept', object: 'for ten hours' },
                { base: 'watch', past: 'watched', ing: 'watching', pastParticiple: 'watched', object: 'a movie' },
                { base: 'study', past: 'studied', ing: 'studying', pastParticiple: 'studied', object: 'for the test' },
                { base: 'play', past: 'played', ing: 'playing', pastParticiple: 'played', object: 'video games' },
                { base: 'read', past: 'read', ing: 'reading', pastParticiple: 'read', object: 'a good book' },
                { base: 'write', past: 'wrote', ing: 'writing', pastParticiple: 'written', object: 'a letter' },
                { base: 'run', past: 'ran', ing: 'running', pastParticiple: 'run', object: 'a marathon' },
                { base: 'see', past: 'saw', ing: 'seeing', pastParticiple: 'seen', object: 'a concert' },
                { base: 'buy', past: 'bought', ing: 'buying', pastParticiple: 'bought', object: 'new shoes' },
                { base: 'make', past: 'made', ing: 'making', pastParticiple: 'made', object: 'a cake' },
                { base: 'take', past: 'took', ing: 'taking', pastParticiple: 'taken', object: 'the bus' },
                { base: 'find', past: 'found', ing: 'finding', pastParticiple: 'found', object: 'the keys' },
                { base: 'give', past: 'gave', ing: 'giving', pastParticiple: 'given', object: 'a gift' },
                { base: 'speak', past: 'spoke', ing: 'speaking', pastParticiple: 'spoken', object: 'English' },
                { base: 'drink', past: 'drank', ing: 'drinking', pastParticiple: 'drunk', object: 'coffee' },
                { base: 'swim', past: 'swam', ing: 'swimming', pastParticiple: 'swum', object: 'in the pool' },
                { base: 'sing', past: 'sang', ing: 'singing', pastParticiple: 'sung', object: 'a song' },
                { base: 'begin', past: 'began', ing: 'beginning', pastParticiple: 'begun', object: 'the project' },
                { base: 'break', past: 'broke', ing: 'breaking', pastParticiple: 'broken', object: 'the vase' },
                { base: 'choose', past: 'chose', ing: 'choosing', pastParticiple: 'chosen', object: 'a winner' },
                { base: 'drive', past: 'drove', ing: 'driving', pastParticiple: 'driven', object: 'to work' },
                { base: 'fly', past: 'flew', ing: 'flying', pastParticiple: 'flown', object: 'to Paris' },
                { base: 'know', past: 'knew', ing: 'knowing', pastParticiple: 'known', object: 'the answer' },
            ],
            subjects: [
                { s: 'I', was: 'was', were: 'was' },
                { s: 'You', was: 'were', were: 'were' },
                { s: 'He', was: 'was', were: 'was' },
                { s: 'She', was: 'was', were: 'was' },
                { s: 'It', was: 'was', were: 'was' },
                { s: 'We', was: 'were', were: 'were' },
                { s: 'They', was: 'were', were: 'were' }
            ],
            timeClauses: [
                'yesterday', 'last night', 'at 8 PM', 'two days ago', 'last week', 'on Monday'
            ],
            conjunctions: [
                { conj: 'and', meaning: 'addition' },
                { conj: 'but', meaning: 'contrast' },
                { conj: 'because', meaning: 'reason' },
                { conj: 'so', meaning: 'result' },
                { conj: 'or', meaning: 'choice' },
                { conj: 'although', meaning: 'contrast' },
                { conj: 'when', meaning: 'time' },
                { conj: 'while', meaning: 'time' }
            ],
            sentencePairs: [
                { s1: 'I studied hard', s2: 'I passed the test', conjunction: 'so' },
                { s1: 'She was tired', s2: 'she went to bed early', conjunction: 'so' },
                { s1: 'I wanted to go out', s2: 'it was raining', conjunction: 'but' },
                { s1: 'He likes pizza', s2: 'his sister prefers pasta', conjunction: 'but' },
                { s1: 'They went home', s2: 'they were tired', conjunction: 'because' },
                { s1: 'We stayed inside', s2: 'it was cold', conjunction: 'because' },
                { s1: 'I was reading a book', s2: 'my brother was playing games', conjunction: 'while' },
                { s1: 'She was cooking dinner', s2: 'he was watching TV', conjunction: 'while' }
            ],
            modalVerbs: [
                { modal: 'can', meaning: 'ability', example: 'swim' },
                { modal: 'could', meaning: 'past ability', example: 'play piano' },
                { modal: 'should', meaning: 'advice', example: 'study harder' },
                { modal: 'must', meaning: 'obligation', example: 'finish homework' },
                { modal: 'may', meaning: 'possibility', example: 'rain tomorrow' },
                { modal: 'might', meaning: 'weak possibility', example: 'be late' },
                { modal: 'would', meaning: 'conditional', example: 'help you' },
                { modal: 'will', meaning: 'future', example: 'arrive soon' }
            ],
            prepositions: [
                { prep: 'in', context: 'the morning', type: 'time' },
                { prep: 'on', context: 'Monday', type: 'time' },
                { prep: 'at', context: '3 PM', type: 'time' },
                { prep: 'in', context: 'New York', type: 'place' },
                { prep: 'on', context: 'the table', type: 'place' },
                { prep: 'at', context: 'the station', type: 'place' },
                { prep: 'by', context: 'car', type: 'method' },
                { prep: 'with', context: 'my friends', type: 'accompaniment' },
                { prep: 'for', context: 'three hours', type: 'duration' },
                { prep: 'since', context: '2020', type: 'time point' }
            ],
            passiveObjects: [
                { active: 'John wrote', object: 'the letter', passive: 'was written by' },
                { active: 'They built', object: 'the house', passive: 'was built by' },
                { active: 'She painted', object: 'the picture', passive: 'was painted by' },
                { active: 'The chef cooked', object: 'the meal', passive: 'was cooked by' },
                { active: 'Someone stole', object: 'my bike', passive: 'was stolen by' },
                { active: 'The company hired', object: 'new workers', passive: 'were hired by' }
            ],
            conditionals: [
                { condition: 'it rains', result: 'we will stay home', type: 'first' },
                { condition: 'I had money', result: 'I would buy a car', type: 'second' },
                { condition: 'she studies', result: 'she will pass', type: 'first' },
                { condition: 'he were rich', result: 'he would travel', type: 'second' },
                { condition: 'you heat ice', result: 'it melts', type: 'zero' },
                { condition: 'I were you', result: 'I would apologize', type: 'second' }
            ],
            getRandom(arr) { return arr[Math.floor(Math.random() * arr.length)]; },
            shuffle(arr) {
                let newArr = [...arr];
                for (let i = newArr.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [newArr[i], newArr[j]] = [newArr[j], newArr[i]];
                }
                return newArr;
            },
            
            createPastSimpleFill() {
                const verb = this.getRandom(this.verbBank);
                const subject = this.getRandom(this.subjects).s;
                const time = this.getRandom(this.timeClauses);
                const q = `${subject} [___] ${verb.object} ${time}.`;
                let distractors = [verb.base, verb.ing, verb.base + 's'];
                if (verb.base === 'read') {
                     distractors = [verb.ing, 'reads', 'readingg'];
                }
                let answers = [verb.past, ...distractors];
                answers = answers.filter((v, i, a) => a.indexOf(v) === i);
                while (answers.length < 4) {
                    answers.push(`verb${answers.length}`);
                }
                answers = answers.slice(0, 4);
                const shuffledAnswers = this.shuffle(answers);
                return { q, a: shuffledAnswers, c: shuffledAnswers.indexOf(verb.past) };
            },

            createPastContinuousFill() {
                const verb = this.getRandom(this.verbBank);
                const subject = this.getRandom(this.subjects);
                const time = this.getRandom(this.timeClauses);
                const q = `${subject.s} ${subject.was} [___] ${verb.object} ${time}.`;
                const correctAnswer = verb.ing;
                let distractors = [verb.past, verb.base, verb.base + 's'];
                let answers = [correctAnswer, ...distractors];
                answers = answers.filter((v, i, a) => a.indexOf(v) === i);
                while (answers.length < 4) {
                    answers.push(`verb${answers.length}`);
                }
                answers = answers.slice(0, 4);
                const shuffledAnswers = this.shuffle(answers);
                return { q, a: shuffledAnswers, c: shuffledAnswers.indexOf(correctAnswer) };
            },

            createConjunctionFill() {
                const pair = this.getRandom(this.sentencePairs);
                const correctAnswer = pair.conjunction;
                const q = `${pair.s1}, [___] ${pair.s2}.`;
                let distractors = this.conjunctions
                    .map(c => c.conj)
                    .filter(c => c !== correctAnswer)
                    .sort(() => Math.random() - 0.5)
                    .slice(0, 3);
                let answers = [correctAnswer, ...distractors];
                answers = answers.filter((v, i, a) => a.indexOf(v) === i);
                while (answers.length < 4) {
                    const extraConj = this.getRandom(this.conjunctions).conj;
                    if (!answers.includes(extraConj)) {
                        answers.push(extraConj);
                    }
                }
                answers = answers.slice(0, 4);
                const shuffledAnswers = this.shuffle(answers);
                return { q, a: shuffledAnswers, c: shuffledAnswers.indexOf(correctAnswer) };
            },

            createPresentPerfectFill() {
                const verb = this.getRandom(this.verbBank);
                const subject = this.getRandom(this.subjects).s;
                const hasHave = ['I', 'You', 'We', 'They'].includes(subject) ? 'have' : 'has';
                const q = `${subject} ${hasHave} [___] ${verb.object}.`;
                const correctAnswer = verb.pastParticiple;
                let distractors = [verb.past, verb.base, verb.ing];
                let answers = [correctAnswer, ...distractors];
                answers = answers.filter((v, i, a) => a.indexOf(v) === i);
                while (answers.length < 4) answers.push(`verb${answers.length}`);
                answers = answers.slice(0, 4);
                const shuffledAnswers = this.shuffle(answers);
                return { q, a: shuffledAnswers, c: shuffledAnswers.indexOf(correctAnswer) };
            },

            createModalVerbFill() {
                const modal = this.getRandom(this.modalVerbs);
                const subject = this.getRandom(['I', 'You', 'He', 'She', 'We', 'They']);
                const q = `${subject} [___] ${modal.example}.`;
                const correctAnswer = modal.modal;
                let distractors = this.modalVerbs
                    .map(m => m.modal)
                    .filter(m => m !== correctAnswer)
                    .sort(() => Math.random() - 0.5)
                    .slice(0, 3);
                let answers = [correctAnswer, ...distractors].slice(0, 4);
                const shuffledAnswers = this.shuffle(answers);
                return { q, a: shuffledAnswers, c: shuffledAnswers.indexOf(correctAnswer) };
            },

            createPrepositionFill() {
                const prep = this.getRandom(this.prepositions);
                const q = `I will meet you [___] ${prep.context}.`;
                const correctAnswer = prep.prep;
                let distractors = this.prepositions
                    .map(p => p.prep)
                    .filter(p => p !== correctAnswer)
                    .sort(() => Math.random() - 0.5)
                    .slice(0, 3);
                let answers = [correctAnswer, ...distractors];
                answers = answers.filter((v, i, a) => a.indexOf(v) === i);
                while (answers.length < 4) {
                    const extra = this.getRandom(this.prepositions).prep;
                    if (!answers.includes(extra)) answers.push(extra);
                }
                answers = answers.slice(0, 4);
                const shuffledAnswers = this.shuffle(answers);
                return { q, a: shuffledAnswers, c: shuffledAnswers.indexOf(correctAnswer) };
            },

            createPassiveVoiceFill() {
                const passive = this.getRandom(this.passiveObjects);
                const q = `${passive.object} [___] ${passive.active.toLowerCase().split(' ')[0]}.`;
                const correctAnswer = passive.passive;
                const distractors = ['is written by', 'wrote by', 'writing by'];
                let answers = [correctAnswer, ...distractors];
                answers = answers.filter((v, i, a) => a.indexOf(v) === i).slice(0, 4);
                const shuffledAnswers = this.shuffle(answers);
                return { q, a: shuffledAnswers, c: shuffledAnswers.indexOf(correctAnswer) };
            },

            createConditionalFill() {
                const cond = this.getRandom(this.conditionals);
                const q = `If ${cond.condition}, [___].`;
                const correctAnswer = cond.result;
                const distractors = this.conditionals
                    .filter(c => c !== cond)
                    .map(c => c.result)
                    .slice(0, 3);
                let answers = [correctAnswer, ...distractors].slice(0, 4);
                const shuffledAnswers = this.shuffle(answers);
                return { q, a: shuffledAnswers, c: shuffledAnswers.indexOf(correctAnswer) };
            },

            generate() {
                const questionTypes = [
                    this.createPastSimpleFill,
                    this.createPastContinuousFill,
                    this.createConjunctionFill,
                    this.createPresentPerfectFill,
                    this.createModalVerbFill,
                    this.createPrepositionFill,
                    this.createPassiveVoiceFill,
                    this.createConditionalFill
                ];
                const randomType = this.getRandom(questionTypes);
                return randomType.call(this);
            }
        };

        // --- 3D Object Creation ---
        function createPlayer3D() {
            const geometry = new THREE.ConeGeometry(0.5, 1, 3);
            const material = new THREE.MeshPhongMaterial({ color: 0x00ffff, emissive: 0x002222 });
            player3D = new THREE.Mesh(geometry, material);
            player3D.castShadow = true;
            player3D.position.y = 0.5;
            scene.add(player3D);

            // Add health bar sprite
            const canvas = document.createElement('canvas');
            canvas.width = 128;
            canvas.height = 32;
            const context = canvas.getContext('2d');
            const texture = new THREE.CanvasTexture(canvas);
            const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.scale.set(2, 0.5, 1);
            sprite.position.y = 2;
            player3D.healthBar = sprite;
            player3D.healthBarContext = context;
            player3D.healthBarTexture = texture;
            player3D.add(sprite);
        }

        function createEnemy3D(enemy) {
            let geometry, material;
            
            if (enemy.shape === 'sphere') {
                geometry = new THREE.SphereGeometry(enemy.size / 2);
            } else if (enemy.shape === 'box') {
                geometry = new THREE.BoxGeometry(enemy.size, enemy.size * 1.5, enemy.size);
            } else {
                geometry = new THREE.BoxGeometry(enemy.size, enemy.size, enemy.size);
            }

            material = new THREE.MeshPhongMaterial({ 
                color: enemy.color,
                emissive: enemy.color,
                emissiveIntensity: 0.2
            });

            const mesh = new THREE.Mesh(geometry, material);
            mesh.castShadow = true;
            mesh.position.set(enemy.x, enemy.size / 2 + (enemy.flying ? 3 : 0), enemy.z);
            mesh.userData = { enemy: enemy };
            scene.add(mesh);
            return mesh;
        }

        function createProjectile3D(proj) {
            const geometry = new THREE.SphereGeometry(proj.size);
            const material = new THREE.MeshPhongMaterial({ 
                color: proj.isCrit ? 0xff0000 : (proj.isCharged ? 0xff00ff : 0x00ffff),
                emissive: proj.isCrit ? 0xff0000 : (proj.isCharged ? 0xff00ff : 0x00ffff),
                emissiveIntensity: 0.8
            });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(proj.x, 1, proj.z);
            mesh.userData = { projectile: proj };
            scene.add(mesh);
            return mesh;
        }

        function createXpOrb3D(orb) {
            const geometry = new THREE.OctahedronGeometry(0.3);
            const material = new THREE.MeshPhongMaterial({ 
                color: 0x39ff14,
                emissive: 0x39ff14,
                emissiveIntensity: 0.5
            });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(orb.x, 0.5, orb.z);
            mesh.userData = { orb: orb };
            scene.add(mesh);
            return mesh;
        }

        function createParticle3D(x, y, z, color) {
            const geometry = new THREE.SphereGeometry(0.1 + Math.random() * 0.2);
            const material = new THREE.MeshBasicMaterial({ color: color });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(x, y, z);
            mesh.userData = {
                velocity: new THREE.Vector3(
                    (Math.random() - 0.5) * 10,
                    Math.random() * 5,
                    (Math.random() - 0.5) * 10
                ),
                lifetime: 1.0
            };
            scene.add(mesh);
            particles3D.push(mesh);
        }

        function spawnParticles3D(x, y, z, color, count) {
            for (let i = 0; i < count; i++) {
                createParticle3D(x, y, z, color);
            }
        }

        // --- Game Initialization ---
        function init() {
            // Clear all 3D objects
            if (scene) {
                enemies3D.forEach(mesh => scene.remove(mesh));
                projectiles3D.forEach(mesh => scene.remove(mesh));
                xpOrbs3D.forEach(mesh => scene.remove(mesh));
                particles3D.forEach(mesh => scene.remove(mesh));
                enemyProjectiles3D.forEach(mesh => scene.remove(mesh));
                orbitalWeapons3D.forEach(mesh => scene.remove(mesh));
                stunProjectiles3D.forEach(mesh => scene.remove(mesh));
                lavaPits3D.forEach(mesh => scene.remove(mesh));
            }

            enemies = []; projectiles = []; xpOrbs = []; powerUpDrops = []; particles = []; enemyProjectiles = []; orbitalWeapons = []; stunProjectiles = []; lavaPits = [];
            enemies3D = []; projectiles3D = []; xpOrbs3D = []; particles3D = []; enemyProjectiles3D = []; orbitalWeapons3D = []; stunProjectiles3D = []; lavaPits3D = [];
            score = 0; gameTime = 0; spawnTimer = 0; gamePaused = false, gameOver = false;
            correctAnswers = 0; incorrectAnswers = 0;
            bossSpawnedLevel3 = false; bossSpawnedLevel5 = false; bossSpawnedLevel10 = false;
            chargeStartTime = 0; isCharging = false; killStreak = 0;
            currentBiome = 'normal'; biomeIndex = 0;
            player = JSON.parse(JSON.stringify(playerStats));
            player.isDashing = false;
            player.dashTimer = 0;
            player.lastDashTime = 0;
            player.rageActive = false;
            player.rageEndTime = 0;

            createPlayer3D();
            updateHUD();
            updateCooldowns();
            [questionModal, levelUpModal, gameOverModal].forEach(m => { if(m) m.classList.add('hidden'); });
            if (gameLoopId) cancelAnimationFrame(gameLoopId);
            gameLoopId = requestAnimationFrame(gameLoop);
        }

        function startGame() {
            if(hud) hud.classList.remove('hidden');
            if(xp_hud) xp_hud.classList.remove('hidden');
            init();
        }

        function endGame() {
            gameOver = true;
            gamePaused = true;
            if(finalScore) finalScore.textContent = score;
            if(finalTime) finalTime.textContent = Math.floor(gameTime) + 's';
            if(finalQuestionsCorrect) finalQuestionsCorrect.textContent = correctAnswers;
            if(finalQuestionsIncorrect) finalQuestionsIncorrect.textContent = incorrectAnswers;
            if(gameOverModal) gameOverModal.classList.remove('hidden');
        }

        // --- Main Game Loop ---
        let lastTime = 0;
        function gameLoop(timestamp) {
            if (gameOver || gamePaused) {
                lastTime = timestamp;
                gameLoopId = requestAnimationFrame(gameLoop);
                return;
            }
            const delta = (timestamp - (lastTime || timestamp)) / 1000 || 0;
            lastTime = timestamp;
            gameTime += delta;

            handleInput(delta);
            update(delta);
            render();

            gameLoopId = requestAnimationFrame(gameLoop);
        }

        // --- Input Handling ---
        let keys = {};
        function handleInput(delta) {
            if (!player || player.isDashing) return;

            let targetVX = 0;
            let targetVZ = 0;

            if (isTouchDevice) {
                targetVX = moveInput.x * player.speed;
                targetVZ = moveInput.y * player.speed;
            } else {
                if (keys['KeyW'] || keys['ArrowUp']) targetVZ = -player.speed;
                if (keys['KeyS'] || keys['ArrowDown']) targetVZ = player.speed;
                if (keys['KeyA'] || keys['ArrowLeft']) targetVX = -player.speed;
                if (keys['KeyD'] || keys['ArrowRight']) targetVX = player.speed;
                if (targetVX !== 0 && targetVZ !== 0) {
                    const length = Math.sqrt(targetVX * targetVX + targetVZ * targetVZ);
                    targetVX = (targetVX / length) * player.speed;
                    targetVZ = (targetVZ / length) * player.speed;
                }
            }

            let lerpFactor = Math.min(1, 15 * delta);
            if (currentBiome === 'ice') {
                lerpFactor = Math.min(1, 5 * delta);
            }
            player.vx = (player.vx ?? 0) * (1 - lerpFactor) + targetVX * lerpFactor;
            player.vz = (player.vz ?? 0) * (1 - lerpFactor) + targetVZ * lerpFactor;
        }

        // --- Update Logic ---
        function update(delta) {
            if(!player || gameOver) return;
            updatePlayer(delta);
            updateEnemies(delta);
            updateProjectiles(delta);
            updateEnemyProjectiles(delta);
            updateOrbitalWeapons(delta);
            updateStunProjectiles(delta);
            updateDrops(delta);
            updateParticles(delta);
            handleCollisions();
            spawnEnemies(delta);
            checkBossSpawns();
            checkRageMode();
            checkKillStreak();
            updateLavaPits(delta);
            updateHUD();
            updateCooldowns();
        }

        function updatePlayer(delta) {
            if (player.isDashing) {
                player.dashTimer -= delta;
                player.vx = player.dashTargetVX;
                player.vz = player.dashTargetVZ;
                if (player.dashTimer <= 0) {
                    player.isDashing = false;
                    player.vx = 0;
                    player.vz = 0;
                }
                player.x += player.vx * delta;
                player.z += player.vz * delta;
                player.x = Math.max(-world.width/2, Math.min(world.width/2, player.x));
                player.z = Math.max(-world.height/2, Math.min(world.height/2, player.z));
                
                if (Math.random() > 0.3) {
                    spawnParticles3D(player.x, 0.5, player.z, 0x00ffff, 2);
                }
                return;
            }

            player.x += player.vx * delta;
            player.z += player.vz * delta;
            player.x = Math.max(-world.width/2, Math.min(world.width/2, player.x));
            player.z = Math.max(-world.height/2, Math.min(world.height/2, player.z));

            // Update 3D position
            if (player3D) {
                player3D.position.x = player.x;
                player3D.position.z = player.z;
                
                // Update rotation to face movement direction
                if (Math.abs(player.vx) > 0.1 || Math.abs(player.vz) > 0.1) {
                    player3D.rotation.y = Math.atan2(player.vx, player.vz);
                }

                // Update health bar
                if (player3D.healthBarContext && player3D.healthBarTexture) {
                    const ctx = player3D.healthBarContext;
                    ctx.clearRect(0, 0, 128, 32);
                    ctx.fillStyle = '#555';
                    ctx.fillRect(0, 0, 128, 32);
                    ctx.fillStyle = 'lime';
                    ctx.fillRect(0, 0, 128 * (player.health / player.maxHealth), 32);
                    player3D.healthBarTexture.needsUpdate = true;
                }

                // Update player light
                if (playerLight) {
                    playerLight.position.x = player.x;
                    playerLight.position.z = player.z;
                }
            }

            // Aiming
            let closestEnemy = null;
            let minDistSq = Infinity;
            enemies.forEach(e => {
                const dx = e.x - player.x; const dz = e.z - player.z;
                const distSq = dx*dx + dz*dz;
                if (distSq < minDistSq) {
                    minDistSq = distSq;
                    closestEnemy = e;
                }
            });

            if (closestEnemy) {
                player.weaponAngle = Math.atan2(closestEnemy.z - player.z, closestEnemy.x - player.x);
            } else {
                player.weaponAngle = 0;
            }

            // Shooting
            if (keys['Space'] || keys['mouseLeft'] || (isTouchDevice && keys['touchShoot'])) {
                if (player.hasChargeShot && !isCharging) {
                    startChargingShot();
                }
                shoot(player.weaponAngle);
            } else if (isCharging) {
                releaseChargeShot();
            }

            if (player.hasStunShot && Math.random() > 0.95) {
                shootStunProjectile(player.weaponAngle);
            }

            // Update camera to follow player
            if (camera) {
                const targetX = player.x;
                const targetZ = player.z + 15;
                camera.position.x += (targetX - camera.position.x) * 0.1;
                camera.position.z += (targetZ - camera.position.z) * 0.1;
                camera.lookAt(player.x, 0, player.z);
            }
        }

        function updateEnemies(delta) {
            enemies.forEach((e, index) => {
                if (e.stunned && e.stunnedUntil > Date.now()) {
                    return;
                } else if (e.stunned) {
                    e.stunned = false;
                }

                const dx = player.x - e.x;
                const dz = player.z - e.z;
                const distSq = dx*dx + dz*dz;
                if (distSq > e.size * e.size) {
                    const dist = Math.sqrt(distSq);
                    e.x += (dx / dist) * e.speed * delta;
                    e.z += (dz / dist) * e.speed * delta;
                }

                // Update 3D position
                if (enemies3D[index]) {
                    enemies3D[index].position.x = e.x;
                    enemies3D[index].position.z = e.z;
                    if (e.flying) {
                        enemies3D[index].position.y = 3 + Math.sin(gameTime * 2 + index) * 0.5;
                    }
                    
                    // Rotate enemies
                    enemies3D[index].rotation.y += delta * 2;
                }

                if (e.isBoss) {
                    const now = Date.now();
                    if (now - e.lastShotTime >= e.shootCooldown) {
                        e.lastShotTime = now;
                        bossShoot(e);
                    }
                }

                if (e.isHealer) {
                    const now = Date.now();
                    if (now - e.lastHealTime >= e.healCooldown) {
                        e.lastHealTime = now;
                        enemies.forEach(target => {
                            if (target.id !== e.id && target.health < target.maxHealth) {
                                const tdx = target.x - e.x;
                                const tdz = target.z - e.z;
                                const distToTarget = Math.sqrt(tdx*tdx + tdz*tdz);
                                if (distToTarget < e.healRadius) {
                                    target.health = Math.min(target.maxHealth, target.health + e.healAmount);
                                    spawnParticles3D(target.x, 1, target.z, 0x00ff88, 5);
                                }
                            }
                        });
                    }
                }
            });
        }

        function updateProjectiles(delta) {
            for (let i = projectiles.length - 1; i >= 0; i--) {
                const p = projectiles[i];
                p.x += p.vx * delta;
                p.z += p.vz * delta;
                p.lifetime -= delta;
                
                if (projectiles3D[i]) {
                    projectiles3D[i].position.x = p.x;
                    projectiles3D[i].position.z = p.z;
                }

                if (p.lifetime <= 0 || Math.abs(p.x) > world.width/2 || Math.abs(p.z) > world.height/2) {
                    if (projectiles3D[i]) {
                        scene.remove(projectiles3D[i]);
                        projectiles3D.splice(i, 1);
                    }
                    projectiles.splice(i, 1);
                }
            }
        }

        function updateEnemyProjectiles(delta) {
            for (let i = enemyProjectiles.length - 1; i >= 0; i--) {
                const p = enemyProjectiles[i];
                p.x += p.vx * delta;
                p.z += p.vz * delta;
                p.lifetime -= delta;
                
                if (enemyProjectiles3D[i]) {
                    enemyProjectiles3D[i].position.x = p.x;
                    enemyProjectiles3D[i].position.z = p.z;
                }

                if (p.lifetime <= 0 || Math.abs(p.x) > world.width/2 || Math.abs(p.z) > world.height/2) {
                    if (enemyProjectiles3D[i]) {
                        scene.remove(enemyProjectiles3D[i]);
                        enemyProjectiles3D.splice(i, 1);
                    }
                    enemyProjectiles.splice(i, 1);
                }
            }
        }

        function bossShoot(boss) {
            if (!player) return;
            const dx = player.x - boss.x;
            const dz = player.z - boss.z;
            const angle = Math.atan2(dz, dx);
            const speed = 10;

            const proj = {
                x: boss.x,
                z: boss.z,
                vx: Math.cos(angle) * speed,
                vz: Math.sin(angle) * speed,
                size: 0.5,
                damage: 20,
                lifetime: 5,
                color: 0xff0000
            };

            enemyProjectiles.push(proj);

            const geometry = new THREE.SphereGeometry(proj.size);
            const material = new THREE.MeshPhongMaterial({ 
                color: proj.color,
                emissive: proj.color,
                emissiveIntensity: 0.8
            });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(proj.x, 1, proj.z);
            scene.add(mesh);
            enemyProjectiles3D.push(mesh);
        }

        function updateDrops(delta) {
            xpOrbs.forEach((orb, index) => {
                const dx = player.x - orb.x;
                const dz = player.z - orb.z;
                const distSq = dx*dx + dz*dz;
                if (distSq < player.pickupRadius * player.pickupRadius) {
                    const speed = 20 * delta;
                    const dist = Math.sqrt(distSq);
                    orb.x += (dx / dist) * speed;
                    orb.z += (dz / dist) * speed;
                }
                
                if (xpOrbs3D[index]) {
                    xpOrbs3D[index].position.x = orb.x;
                    xpOrbs3D[index].position.z = orb.z;
                    xpOrbs3D[index].rotation.y += delta * 3;
                }
            });
        }

        function updateParticles(delta) {
            for (let i = particles3D.length - 1; i >= 0; i--) {
                const p = particles3D[i];
                p.userData.lifetime -= delta;
                p.position.x += p.userData.velocity.x * delta;
                p.position.y += p.userData.velocity.y * delta;
                p.position.z += p.userData.velocity.z * delta;
                p.userData.velocity.y -= 10 * delta; // Gravity
                p.scale.multiplyScalar(1 - delta * 2);
                
                if (p.userData.lifetime <= 0 || p.scale.x <= 0.01) {
                    scene.remove(p);
                    particles3D.splice(i, 1);
                }
            }
        }

        function handleCollisions() {
            if (!player) return;
            
            // Projectile vs Enemy
            for (let pi = projectiles.length - 1; pi >= 0; pi--) {
                const p = projectiles[pi];
                for (let ei = enemies.length - 1; ei >= 0; ei--) {
                    const e = enemies[ei];
                    if (p.hitEnemies?.includes(e.id)) continue;

                    const dx = e.x - p.x; const dz = e.z - p.z;
                    const distSq = dx*dx + dz*dz;
                    if (distSq < (e.size + p.size) * (e.size + p.size)) {
                        handleEnemyHit(e, p.damage);
                        spawnParticles3D(p.x, 1, p.z, 0xffffff, 3);
                        if (!p.hitEnemies) p.hitEnemies = [];
                        p.hitEnemies.push(e.id);
                        if (p.pierceCount <= 0) {
                            if (projectiles3D[pi]) {
                                scene.remove(projectiles3D[pi]);
                                projectiles3D.splice(pi, 1);
                            }
                            projectiles.splice(pi, 1);
                            break;
                        } else {
                            p.pierceCount--;
                        }
                    }
                }
            }

            // Player vs Enemy
            for (let i = enemies.length - 1; i >= 0; i--) {
                const e = enemies[i];
                if (player.isDashing) continue;
                const dx = player.x - e.x; const dz = player.z - e.z;
                if (dx*dx + dz*dz < (player.size + e.size) * (player.size + e.size)) {
                    const damageReduction = player.damageReduction || 0;
                    const actualDamage = e.damage * (1 - damageReduction);
                    player.health -= actualDamage;
                    const angle = Math.atan2(dz, dx);
                    e.x -= Math.cos(angle) * e.size * 0.5;
                    e.z -= Math.sin(angle) * e.size * 0.5;
                    if (player.health <= 0) {
                        player.health = 0;
                        endGame();
                    }
                }
            }

            // Player vs XP Orb
            for (let i = xpOrbs.length - 1; i >= 0; i--) {
                const orb = xpOrbs[i];
                const dx = player.x - orb.x; const dz = player.z - orb.z;
                if(dx*dx + dz*dz < player.size * player.size) {
                    gainXp(orb.value);
                    if (xpOrbs3D[i]) {
                        scene.remove(xpOrbs3D[i]);
                        xpOrbs3D.splice(i, 1);
                    }
                    xpOrbs.splice(i, 1);
                }
            }

            // Enemy Projectiles vs Player
            for (let i = enemyProjectiles.length - 1; i >= 0; i--) {
                const p = enemyProjectiles[i];
                if (player.isDashing) continue;
                const dx = player.x - p.x; const dz = player.z - p.z;
                if (dx*dx + dz*dz < (player.size + p.size) * (player.size + p.size)) {
                    const damageReduction = player.damageReduction || 0;
                    const actualDamage = p.damage * (1 - damageReduction);
                    player.health -= actualDamage;
                    spawnParticles3D(p.x, 1, p.z, 0xff0000, 5);
                    if (enemyProjectiles3D[i]) {
                        scene.remove(enemyProjectiles3D[i]);
                        enemyProjectiles3D.splice(i, 1);
                    }
                    enemyProjectiles.splice(i, 1);
                    if (player.health <= 0) {
                        player.health = 0;
                        endGame();
                    }
                }
            }
        }

        function handleEnemyHit(enemy, damage) {
            enemy.health -= damage;
            if (enemy.health <= 0) {
                const index = enemies.findIndex(e => e.id === enemy.id);
                if (index > -1) {
                    killEnemy(enemies[index], index);
                }
            }
        }

        function killEnemy(enemy, index) {
            score++;
            killStreak++;
            createXpOrb(enemy.x, enemy.z, enemy.xp);
            spawnParticles3D(enemy.x, 1, enemy.z, enemy.color, 20);

            if (player.lifesteal && player.lifesteal > 0) {
                player.health = Math.min(player.maxHealth, player.health + player.lifesteal);
                spawnParticles3D(player.x, 1, player.z, 0x00ff00, 5);
            }

            if (enemy.isBomber) {
                const dx = player.x - enemy.x;
                const dz = player.z - enemy.z;
                const distToPlayer = Math.sqrt(dx*dx + dz*dz);
                if (distToPlayer < enemy.explosionRadius) {
                    if (!player.isDashing) {
                        player.health -= enemy.explosionDamage;
                        if (player.health <= 0) {
                            player.health = 0;
                            endGame();
                        }
                    }
                }
                spawnParticles3D(enemy.x, 1, enemy.z, 0xffaa00, 40);
            }

            if (enemy.isSplitter) {
                for (let i = 0; i < 2; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const offset = 3;
                    const newEnemy = {
                        id: Math.random(),
                        x: enemy.x + Math.cos(angle) * offset,
                        z: enemy.z + Math.sin(angle) * offset,
                        id_key: "Swarm",
                        name: "Swarm",
                        size: 0.4,
                        speed: 14,
                        health: 10,
                        xp: 8,
                        shape: 'cube',
                        color: enemy.color,
                        damage: 5,
                        maxHealth: 10
                    };
                    enemies.push(newEnemy);
                    enemies3D.push(createEnemy3D(newEnemy));
                }
            }

            if (enemy.isBoss) {
                changeBiome();
            }

            if (enemies3D[index]) {
                scene.remove(enemies3D[index]);
                enemies3D.splice(index, 1);
            }
            enemies.splice(index, 1);
        }

        function spawnEnemies(delta) {
            spawnTimer -= delta;
            const spawnInterval = Math.max(0.1, 1.5 - gameTime / 120);
            const maxEnemies = 20 + player.level * 10;
            if (spawnTimer <= 0 && enemies.length < maxEnemies) {
                spawnEnemy();
                spawnTimer = spawnInterval * (0.8 + Math.random() * 0.4);
            }
        }

        function spawnEnemy() {
            const type = enemyTypes[Math.floor(Math.random() * enemyTypes.length)];
            const spawnDist = 30;
            const angle = Math.random() * Math.PI * 2;
            const x = player.x + Math.cos(angle) * spawnDist;
            const z = player.z + Math.sin(angle) * spawnDist;

            const enemy = {
                id: Math.random(), x: x, z: z, ...type,
                health: type.health * (1 + gameTime / 90),
                maxHealth: type.health * (1 + gameTime / 90)
            };

            enemies.push(enemy);
            enemies3D.push(createEnemy3D(enemy));
        }

        function checkBossSpawns() {
            if (!player) return;

            if (player.level >= 3 && !bossSpawnedLevel3) {
                bossSpawnedLevel3 = true;
                spawnBoss();
            }

            if (player.level >= 5 && !bossSpawnedLevel5) {
                bossSpawnedLevel5 = true;
                spawnBoss();
            }

            if (player.level >= 10 && !bossSpawnedLevel10) {
                bossSpawnedLevel10 = true;
                spawnBoss();
            }
        }

        function spawnBoss() {
            const spawnDist = 35;
            const angle = Math.random() * Math.PI * 2;
            const x = player.x + Math.cos(angle) * spawnDist;
            const z = player.z + Math.sin(angle) * spawnDist;

            const boss = {
                id: Math.random(), x: x, z: z, ...bossType,
                health: bossType.health,
                maxHealth: bossType.health,
                lastShotTime: Date.now()
            };

            enemies.push(boss);
            enemies3D.push(createEnemy3D(boss));
        }

        function changeBiome() {
            biomeIndex = (biomeIndex + 1) % biomeOrder.length;
            currentBiome = biomeOrder[biomeIndex];

            lavaPits3D.forEach(mesh => scene.remove(mesh));
            lavaPits = [];
            lavaPits3D = [];

            const biomeInfo = biomes[currentBiome];
            
            // Update ground color
            if (groundMesh) {
                groundMesh.material.color.setHex(biomeInfo.groundColor);
            }

            // Update fog
            scene.fog = new THREE.Fog(biomeInfo.fogColor, 10, 100);

            // Update ambient light
            if (currentBiome === 'ice') {
                ambientLight.color.setHex(0x6688aa);
            } else if (currentBiome === 'heat') {
                ambientLight.color.setHex(0x886644);
                spawnLavaPits();
            } else {
                ambientLight.color.setHex(0x404040);
            }

            spawnParticles3D(player.x, 1, player.z, biomeInfo.gridColor, 50);
        }

        function spawnLavaPits() {
            const biomeInfo = biomes.heat;
            const numPits = biomeInfo.maxLavaPits || 8;

            for (let i = 0; i < numPits; i++) {
                const x = (Math.random() - 0.5) * world.width;
                const z = (Math.random() - 0.5) * world.height;
                const size = 5 + Math.random() * 10;

                const pit = {
                    x: x,
                    z: z,
                    size: size,
                    damage: biomeInfo.lavaDamage,
                    lastDamageTime: 0
                };
                lavaPits.push(pit);

                // Create 3D lava pit
                const geometry = new THREE.CylinderGeometry(size/2, size/2, 0.2, 16);
                const material = new THREE.MeshPhongMaterial({ 
                    color: biomeInfo.lavaColor,
                    emissive: biomeInfo.lavaColor,
                    emissiveIntensity: 0.8
                });
                const mesh = new THREE.Mesh(geometry, material);
                mesh.position.set(x, 0, z);
                scene.add(mesh);
                lavaPits3D.push(mesh);
            }
        }

        function updateLavaPits(delta) {
            if (currentBiome !== 'heat' || !player) return;

            const now = Date.now();
            for (let pit of lavaPits) {
                const dx = player.x - pit.x;
                const dz = player.z - pit.z;
                const dist = Math.sqrt(dx*dx + dz*dz);

                if (dist < pit.size / 2 + player.size) {
                    if (now - pit.lastDamageTime > 500) {
                        if (!player.isDashing) {
                            player.health -= pit.damage;
                            spawnParticles3D(player.x, 0.5, player.z, 0xff4400, 5);

                            if (player.health <= 0) {
                                player.health = 0;
                                endGame();
                            }
                        }
                        pit.lastDamageTime = now;
                    }
                }
            }
        }

        function shoot(angle) {
            if (!player) return;
            if (player.ammo <= 0) { 
                askQuestion(); 
                return; 
            }
            if (Date.now() - lastShotTime < player.fireRate) return;
            
            player.ammo--;
            lastShotTime = Date.now();
            const spreadAngle = 0.15;

            for (let i = 0; i < player.shotCount; i++) {
                let currentAngle = angle;
                if (player.shotCount > 1) {
                    const totalSpread = spreadAngle * (player.shotCount - 1);
                    currentAngle += totalSpread / 2 - spreadAngle * i;
                }
                
                spawnParticles3D(
                    player.x + Math.cos(currentAngle) * 1.5,
                    1,
                    player.z + Math.sin(currentAngle) * 1.5,
                    0xffffaa,
                    3
                );

                let damage = player.projectileDamage;
                let isCrit = false;
                if (player.critChance && Math.random() < player.critChance) {
                    damage *= 2;
                    isCrit = true;
                }

                const proj = {
                    x: player.x, z: player.z,
                    vx: Math.cos(currentAngle) * player.projectileSpeed,
                    vz: Math.sin(currentAngle) * player.projectileSpeed,
                    size: player.projectileSize,
                    damage: damage,
                    lifetime: player.projectileLifetime || 3,
                    pierceCount: player.pierce,
                    hitEnemies: [],
                    isCrit: isCrit
                };

                projectiles.push(proj);
                projectiles3D.push(createProjectile3D(proj));
            }
        }

        function createXpOrb(x, z, value) {
            const orb = { x: x, z: z, size: 0.3, value: value, color: 0x39ff14 };
            xpOrbs.push(orb);
            xpOrbs3D.push(createXpOrb3D(orb));
        }

        function triggerDash() {
            if (!player || player.isDashing || gamePaused) return;
            const now = Date.now();
            if (now - player.lastDashTime < player.dashCooldown) return;

            player.lastDashTime = now;
            player.isDashing = true;
            player.dashTimer = player.dashDuration / 1000;

            let dashDirX = player.vx;
            let dashDirZ = player.vz;
            let mag = Math.hypot(dashDirX, dashDirZ);

            if (mag < 1) {
                dashDirX = Math.cos(player.weaponAngle);
                dashDirZ = Math.sin(player.weaponAngle);
            } else {
                dashDirX /= mag;
                dashDirZ /= mag;
            }

            player.dashTargetVX = dashDirX * player.dashSpeed;
            player.dashTargetVZ = dashDirZ * player.dashSpeed;

            if (touchDashCooldown) {
                touchDashCooldown.style.transition = 'none';
                touchDashCooldown.style.transform = 'translateY(0%)';
            }
        }

        function triggerBomb() {
            if (!player || gamePaused) return;
            if (player.bombs <= 0) return;
            const now = Date.now();
            if (now - player.lastBombTime < player.bombCooldown) return;

            player.bombs--;
            player.lastBombTime = now;

            spawnParticles3D(player.x, 1, player.z, 0xffaa00, 100);
            spawnParticles3D(player.x, 1, player.z, 0xff4400, 80);

            for (let i = enemies.length - 1; i >= 0; i--) {
                const e = enemies[i];
                const dx = e.x - player.x;
                const dz = e.z - player.z;
                const dist = Math.sqrt(dx*dx + dz*dz);
                if (dist < player.bombRadius) {
                    handleEnemyHit(e, player.bombDamage);
                }
            }

            for (let i = enemyProjectiles.length - 1; i >= 0; i--) {
                const p = enemyProjectiles[i];
                const dx = p.x - player.x;
                const dz = p.z - player.z;
                const dist = Math.sqrt(dx*dx + dz*dz);
                if (dist < player.bombRadius) {
                    if (enemyProjectiles3D[i]) {
                        scene.remove(enemyProjectiles3D[i]);
                        enemyProjectiles3D.splice(i, 1);
                    }
                    enemyProjectiles.splice(i, 1);
                }
            }
        }

        function addOrbitalWeapon() {
            const orbitalCount = player.orbitalCount || 0;
            const angleOffset = (Math.PI * 2 / Math.max(1, orbitalCount)) * (orbitalCount - 1);
            const weapon = {
                angle: angleOffset,
                distance: 3,
                size: 0.5,
                damage: 40,
                color: 0xc0c0c0,
                speed: 2
            };
            orbitalWeapons.push(weapon);

            // Create 3D orbital weapon
            const geometry = new THREE.BoxGeometry(weapon.size, weapon.size * 2, weapon.size / 4);
            const material = new THREE.MeshPhongMaterial({ color: weapon.color });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.userData = { weapon: weapon };
            scene.add(mesh);
            orbitalWeapons3D.push(mesh);
        }

        function updateOrbitalWeapons(delta) {
            orbitalWeapons.forEach((weapon, wIndex) => {
                weapon.angle += weapon.speed * delta;
                weapon.x = player.x + Math.cos(weapon.angle) * weapon.distance;
                weapon.z = player.z + Math.sin(weapon.angle) * weapon.distance;

                if (orbitalWeapons3D[wIndex]) {
                    orbitalWeapons3D[wIndex].position.x = weapon.x;
                    orbitalWeapons3D[wIndex].position.y = 1;
                    orbitalWeapons3D[wIndex].position.z = weapon.z;
                    orbitalWeapons3D[wIndex].rotation.y += delta * 5;
                }

                for (let i = enemies.length - 1; i >= 0; i--) {
                    const e = enemies[i];
                    const dx = e.x - weapon.x;
                    const dz = e.z - weapon.z;
                    const dist = Math.sqrt(dx*dx + dz*dz);
                    if (dist < (e.size + weapon.size)) {
                        handleEnemyHit(e, weapon.damage);
                        spawnParticles3D(weapon.x, 1, weapon.z, 0xffaa00, 5);
                    }
                }
            });
        }

        function shootStunProjectile(angle) {
            const proj = {
                x: player.x,
                z: player.z,
                vx: Math.cos(angle) * 20,
                vz: Math.sin(angle) * 20,
                size: 0.2,
                damage: 5,
                stunDuration: 2,
                lifetime: 10,
                color: 0x00ffff
            };
            stunProjectiles.push(proj);

            const geometry = new THREE.SphereGeometry(proj.size);
            const material = new THREE.MeshPhongMaterial({ 
                color: proj.color,
                emissive: proj.color,
                emissiveIntensity: 1.0
            });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(proj.x, 1, proj.z);
            scene.add(mesh);
            stunProjectiles3D.push(mesh);
        }

        function updateStunProjectiles(delta) {
            for (let i = stunProjectiles.length - 1; i >= 0; i--) {
                const p = stunProjectiles[i];
                p.x += p.vx * delta;
                p.z += p.vz * delta;
                p.lifetime -= delta;

                if (stunProjectiles3D[i]) {
                    stunProjectiles3D[i].position.x = p.x;
                    stunProjectiles3D[i].position.z = p.z;
                }

                if (p.lifetime <= 0 || Math.abs(p.x) > world.width/2 || Math.abs(p.z) > world.height/2) {
                    if (stunProjectiles3D[i]) {
                        scene.remove(stunProjectiles3D[i]);
                        stunProjectiles3D.splice(i, 1);
                    }
                    stunProjectiles.splice(i, 1);
                    continue;
                }

                enemies.forEach(e => {
                    const dx = e.x - p.x;
                    const dz = e.z - p.z;
                    const dist = Math.sqrt(dx*dx + dz*dz);
                    if (dist < (e.size + p.size)) {
                        e.stunned = true;
                        e.stunnedUntil = Date.now() + p.stunDuration * 1000;
                        handleEnemyHit(e, p.damage);
                        spawnParticles3D(p.x, 1, p.z, 0x00ffff, 3);
                    }
                });
            }
        }

        function startChargingShot() {
            if (!player.hasChargeShot) return;
            isCharging = true;
            chargeStartTime = Date.now();
        }

        function releaseChargeShot() {
            if (!isCharging || !player.hasChargeShot) return;
            const chargeTime = (Date.now() - chargeStartTime) / 1000;
            isCharging = false;

            if (chargeTime < 0.5) return;

            const chargePower = Math.min(3, chargeTime / 1.5);
            const angle = player.weaponAngle;

            spawnParticles3D(player.x, 1, player.z, 0xff00ff, 30);

            const proj = {
                x: player.x,
                z: player.z,
                vx: Math.cos(angle) * 15,
                vz: Math.sin(angle) * 15,
                size: 0.5 * chargePower,
                damage: player.projectileDamage * chargePower * 5,
                lifetime: 5,
                pierceCount: 999,
                hitEnemies: [],
                isCharged: true,
                chargePower: chargePower
            };

            projectiles.push(proj);
            projectiles3D.push(createProjectile3D(proj));
        }

        function checkRageMode() {
            if (!player.hasRageMode) return;
            const now = Date.now();

            if (player.health < player.maxHealth * 0.3 && !player.rageActive) {
                player.rageActive = true;
                player.rageEndTime = now + 10000;
                player.rageSpeed = player.speed;
                player.rageDamage = player.projectileDamage;
                player.rageFireRate = player.fireRate;
                player.speed *= 2;
                player.projectileDamage *= 2;
                player.fireRate *= 2;
                spawnParticles3D(player.x, 1, player.z, 0xff0000, 50);
            }

            if (player.rageActive && now > player.rageEndTime) {
                player.rageActive = false;
                player.speed = player.rageSpeed;
                player.projectileDamage
